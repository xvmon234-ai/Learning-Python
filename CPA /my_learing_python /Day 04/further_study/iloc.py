# ==============================================================================
# [문제 4.2] 추가 학습: `.iloc[]`의 정확한 사용과 CPA 활용
# ==============================================================================

# 데이터 준비 예시
# (이론 설명을 위한 데이터로, 실제 문제 4.1의 데이터와 동일합니다.)
products_data = """OrderID,Product,Quantity,Price
1,Laptop,1,1200
2,Mouse,2,25
3,Keyboard,1,75
4,Monitor,1,300
"""
df_products = pd.read_csv(StringIO(products_data))

print("--- 예시 DataFrame (df_products) ---")
print(df_products)

# 핵심 이론: `.iloc[]`의 위치 기반 인덱싱
"""
Pandas의 `.iloc[]`는 **정수 위치(Integer-location based)**를 사용하여 DataFrame의 행과 열을 선택하는 강력한 인덱싱 도구입니다. Python의 리스트 인덱싱과 유사하게 0부터 시작하는 정수 인덱스를 사용합니다.

**주요 특징 및 사용법**:

1.  **정수 위치만 사용**:
    * `.iloc[]`는 오직 정수 위치 인덱스만 허용합니다. 라벨(이름) 인덱스는 사용할 수 없습니다.
    * `df.iloc[행_위치, 열_위치]` 형태로 사용합니다.

2.  **행 선택**:
    * **단일 행 선택**: `df.iloc[정수_위치]`
        * 예: `df.iloc[0]`는 첫 번째 행을 선택합니다. 결과는 Series 객체입니다.
    * **여러 행 선택 (리스트)**: `df.iloc[[정수_위치1, 정수_위치2, ...]]`
        * 예: `df.iloc[[1, 3]]`는 두 번째와 네 번째 행을 선택합니다. 결과는 DataFrame 객체입니다.
    * **슬라이싱**: `df.iloc[시작_위치 : 끝_위치]`
        * 예: `df.iloc[0:2]`는 첫 번째(`0`)부터 세 번째(`2`는 포함하지 않음) 행까지, 즉 `0`과 `1` 인덱스의 행을 선택합니다. Python 슬라이싱 규칙과 동일하게 **끝 위치는 포함하지 않습니다.** 결과는 DataFrame 객체입니다.

3.  **열 선택**:
    * 행 선택과 동일한 방식으로 열의 정수 위치를 지정하여 선택할 수 있습니다.
    * `df.iloc[:, 열_위치]` (모든 행을 선택하고 특정 열)
    * `df.iloc[:, [열_위치1, 열_위치2]]`
    * `df.iloc[:, 시작_위치 : 끝_위치]`

4.  **특정 셀 또는 블록 선택**:
    * `df.iloc[행_위치, 열_위치]`
    * `df.iloc[[행_위치1, 행_위치2], [열_위치1, 열_위치2]]`
    * `df.iloc[행_슬라이싱, 열_슬라이싱]`

**`.iloc[]` 사용 시 주의사항**:
* 인덱스 라벨이 아닌 **물리적인 위치**에 기반하므로, 데이터가 정렬되거나 행이 추가/삭제되면 동일한 인덱스 번호가 다른 데이터를 가리킬 수 있습니다.
* 슬라이싱 시 **끝 위치가 포함되지 않는다는 점**을 항상 기억해야 합니다.

**왜 중요한가?**:
데이터의 물리적인 순서나 위치에 따라 데이터를 추출해야 할 때, 또는 인덱스 라벨이 없거나 의미가 없는 경우에 `iloc[]`는 매우 유용하고 직관적인 방법입니다. 특히 대규모 데이터셋에서 특정 샘플을 추출하거나, 시스템 로그와 같이 순서가 중요한 데이터를 다룰 때 효율적입니다.
"""

# `.iloc[]` 사용 예시
# 단일 행 선택 (Series 반환)
first_row = df_products.iloc[0]
print("\n--- 첫 번째 행 (인덱스 0) 선택 ---")
print(first_row)
print(f"타입: {type(first_row)}")

# 여러 행 선택 (DataFrame 반환) - 리스트 인덱싱
selected_rows_iloc = df_products.iloc[[1, 3]]
print("\n--- 인덱스 1과 3의 행 선택 (이중 리스트) ---")
print(selected_rows_iloc)
print(f"타입: {type(selected_rows_iloc)}")

# 슬라이싱으로 여러 행 선택 (DataFrame 반환)
slice_rows_iloc = df_products.iloc[0:2] # 0, 1 인덱스 포함
print("\n--- 인덱스 0부터 1까지 슬라이싱 (끝 인덱스 2는 미포함) ---")
print(slice_rows_iloc)

# 특정 행의 특정 컬럼 선택 (예: 첫 번째 행의 세 번째 컬럼)
specific_value = df_products.iloc[0, 2]
print(f"\n--- 첫 번째 행(0), 세 번째 컬럼(2)의 값: {specific_value} ---")


print("\n[공인회계사(CPA) 업무와의 관련성]:")
"""
`iloc[]`를 사용한 **행 위치 기반 선택**은 공인회계사(CPA)가 **특정 거래, 특정 기간의 데이터 등 물리적인 위치에 기반하여 데이터를 신속하게 검토**해야 할 때 매우 유용합니다.
특히 정형화된 보고서나 시스템 로그를 다룰 때 빛을 발합니다.

* **샘플링 및 표본 추출**:
    * **활용**: 수만 건의 거래 데이터 중 무작위 또는 **시스템상 10번째, 50번째, 100번째와 같이 특정 순서에 해당하는 거래**를 추출하여 감사 표본으로 삼을 때 `iloc[]`를 활용할 수 있습니다. 예를 들어, `df_transactions.iloc[[9, 49, 99]]` (파이썬은 0부터 시작하므로)와 같이 사용합니다.
    * **의미**: CPA는 이를 통해 특정 감사 절차(예: 매출 발생 시점 감사, 지출 승인 검토)를 위한 표본을 효율적으로 선택하고 검증할 수 있습니다.

* **로그 및 이벤트 데이터 검토**:
    * **활용**: 시스템 접근 로그, 사용자 활동 기록 등 **시간 순서대로 기록된 데이터**에서 **최초 몇 줄 또는 특정 시점 이후의 몇 줄**만 빠르게 확인하여 초기 상황 파악이나 특정 이벤트 전후를 분석할 때 유용합니다.
    * **의미**: 예를 들어, `df_logs.iloc[0:5]` (첫 5개 로그 확인) 또는 `df_logs.iloc[-10:]` (최근 10개 로그 확인)와 같이 사용하여 시스템의 비정상적인 활동이나 중요한 이벤트의 발생 여부를 초기에 탐지할 수 있습니다.

* **데이터 형식 및 오류 사전 점검**:
    * **활용**: 대량의 데이터 파일을 처음 로드했을 때, 파일의 **맨 앞 몇 줄(`iloc[0:n]`)**이나 **맨 뒤 몇 줄(`iloc[-n:]`)**을 확인하여 데이터가 올바른 형식으로 로드되었는지, 예상치 못한 헤더나 푸터가 있는지 등을 빠르게 검토합니다.
    * **의미**: CPA는 이를 통해 데이터 클리닝 또는 가공 전에 데이터의 품질을 신속하게 파악하고, 잠재적인 오류를 미리 발견하여 분석 작업의 효율성을 높일 수 있습니다.

* **반복적인 수작업 자동화**:
    * **활용**: 과거에는 수작업으로 특정 위치의 데이터를 추출하여 검토했다면, 이제는 `iloc[]`를 활용하여 이러한 반복 작업을 자동화하여 **시간을 절약하고 휴먼 에러를 줄일 수** 있습니다.

결론적으로, `iloc[]`는 CPA가 **대규모 데이터셋 내에서 특정 위치의 데이터를 빠르고 정확하게 식별하고 추출하여, 감사 샘플링, 데이터 품질 검증, 이상 징후 초기 탐지** 등에 활용할 수 있는 중요한 도구입니다.
"""
