# ==============================================================================
# [문제 4.3] 추가 학습: `.loc[]`의 정확한 사용과 CPA 활용
# ==============================================================================

# 데이터 준비 예시
# (이론 설명을 위한 데이터로, 문제 4.3의 데이터와 동일합니다.)
students_data = """StudentID,Name,Math,English,Grade
S001,Alice,90,85,A
S002,Bob,78,80,B
S003,Charlie,95,92,A
S004,David,60,70,C
"""
# 'StudentID' 컬럼을 인덱스로 설정
df_students = pd.read_csv(StringIO(students_data)).set_index("StudentID")

print("--- 예시 DataFrame (df_students - 'StudentID' 인덱스 설정) ---")
print(df_students)
print("\n--- DataFrame 정보 ---")
df_students.info()

# 핵심 이론: `.loc[]`의 라벨 기반 인덱싱
"""
Pandas의 `.loc[]`는 **라벨(Label-based)**을 사용하여 DataFrame의 행과 열을 선택하는 강력한 인덱싱 도구입니다. 행 인덱스 라벨(또는 이름)과 컬럼 이름(라벨)을 직접 사용하여 데이터를 선택합니다.

**주요 특징 및 사용법**:

1.  **라벨(이름)만 사용**:
    * `.loc[]`는 오직 행 인덱스의 라벨과 컬럼의 이름만 허용합니다. 정수 위치 인덱스는 사용할 수 없습니다.
    * `df.loc[행_라벨, 열_라벨]` 형태로 사용합니다.

2.  **행 선택**:
    * **단일 행 선택**: `df.loc[단일_행_라벨]`
        * 예: `df.loc["S001"]`는 첫 번째 행을 선택합니다. 결과는 Series 객체입니다.
    * **여러 행 선택 (리스트)**: `df.loc[[라벨1, 라벨2, ...]]`
        * 예: `df.loc[["S001", "S003"]]`는 'S001'과 'S003' 라벨을 가진 행을 선택합니다. 결과는 DataFrame 객체입니다.
    * **슬라이싱**: `df.loc[시작_라벨 : 끝_라벨]`
        * 예: `df.loc["S001":"S003"]`는 'S001'부터 'S003' 라벨까지의 행을 선택합니다. **`.iloc[]`와 달리, `.loc[]`의 슬라이싱은 끝 라벨을 포함합니다.** 결과는 DataFrame 객체입니다.

3.  **열 선택**:
    * 행 선택과 동일한 방식으로 열의 이름을 지정하여 선택할 수 있습니다.
    * `df.loc[:, 단일_열_이름]` (모든 행을 선택하고 특정 열)
    * `df.loc[:, [열_이름1, 열_이름2]]`
    * `df.loc[:, 시작_열_이름 : 끝_열_이름]` (연속된 컬럼을 선택할 때)

4.  **특정 셀 또는 블록 선택**:
    * `df.loc[행_라벨, 열_라벨]`
    * `df.loc[[행_라벨1, 행_라벨2], [열_라벨1, 열_라벨2]]`
    * `df.loc[행_슬라이싱, 열_슬라이싱]`

**`.loc[]` 사용 시 주의사항**:
* 인덱스 라벨이나 컬럼 이름이 중복되는 경우, 해당 라벨을 가진 모든 행/열이 선택됩니다.
* 슬라이싱 시 **끝 라벨이 포함된다는 점**을 항상 기억해야 합니다.

**왜 중요한가?**:
데이터의 실제 이름이나 식별자를 사용하여 데이터를 추출해야 할 때 `loc[]`는 매우 강력하고 직관적입니다. 특히 데이터베이스의 기본 키(Primary Key)와 같이 고유한 식별자를 인덱스로 설정했을 때, 특정 엔티티(예: 특정 고객, 특정 제품)의 모든 정보를 조회하는 데 최적화되어 있습니다.
"""

# `.loc[]` 사용 예시
# 단일 라벨 행 선택 (Series 반환)
student_s001_loc = df_students.loc["S001"]
print("\n--- 'S001' 학생 정보 (Series) 선택 ---")
print(student_s001_loc)
print(f"타입: {type(student_s001_loc)}")

# 여러 라벨 행 선택 (DataFrame 반환) - 리스트 인덱싱
selected_students_loc = df_students.loc[["S001", "S003"]]
print("\n--- 'S001'과 'S003' 학생 정보 (DataFrame) 선택 ---")
print(selected_students_loc)
print(f"타입: {type(selected_students_loc)}")

# 라벨 슬라이싱 (끝 라벨 포함)
slice_students_loc = df_students.loc["S001":"S003"] # 'S003' 인덱스도 포함
print("\n--- 'S01'부터 'S03'까지 슬라이싱 (끝 인덱스 'S003' 포함) ---")
print(slice_students_loc)

# 특정 행의 특정 컬럼 선택 (행 라벨, 컬럼 라벨)
grade_s002 = df_students.loc["S002", "Grade"]
print(f"\n--- 'S002' 학생의 'Grade' 값: {grade_s002} ---")

# 특정 행의 여러 컬럼 선택
math_english_s001 = df_students.loc["S001", ["Math", "English"]]
print(f"\n--- 'S001' 학생의 'Math'와 'English' 점수 ---")
print(math_english_s001)


print("\n[공인회계사(CPA) 업무와의 관련성]:")
"""
`df[['컬럼1', '컬럼2']]`를 사용한 **다중 컬럼 선택**과 `df.loc['인덱스이름']`을 사용한 **라벨 기반 행 선택**은
공인회계사(CPA)가 **특정 거래의 전체 내용(행) 또는 특정 정보(컬럼)만을 빠르고 정확하게 추출하여 감사 및 분석에 활용**할 때 매우 중요합니다.

* **다중 컬럼 선택 (복습 및 심화)**:
    * **활용**: 회사의 **전표 데이터**에서 '전표번호', '계정과목', '차변금액', '대변금액' 등 **감사 또는 재무 보고에 필요한 핵심 컬럼들만 동시에 선택**하여 분석합니다.
    * **의미**: CPA는 이를 통해 특정 거래의 재무적 영향만을 집중적으로 분석하거나, 재무제표 작성에 필요한 필수 데이터를 효율적으로 추출할 수 있습니다. 예를 들어, `df_journal[['Date', 'Account', 'Debit', 'Credit']]`와 같이 사용합니다.

* **라벨 기반 행 선택 (`.loc[]`)**:
    * **활용**: '거래번호', '고객ID', '자산ID' 등이 인덱스로 설정된 데이터에서 **특정 고객ID(`'CUST005'`) 또는 특정 자산ID(`'ASSET123'`)에 해당하는 모든 거래나 자산 정보(해당 행 전체)**를 조회합니다.
    * **의미**: CPA는 특정 거래의 상세 내역을 파악하거나, 특정 감사 샘플(예: 특정 고객에 대한 매출채권 확인)의 데이터를 빠르게 조회하여 증거를 확보할 수 있습니다. 이는 인덱스가 명확한 데이터(예: 고유 ID)에서 특히 강력한 효과를 발휘합니다.

* **특정 문서/보고서 생성의 정밀성**:
    * **활용**: CPA는 다양한 내부 보고서나 외부 공시 자료를 작성할 때, 원본 데이터에서 **필요한 특정 정보(컬럼)와 관련된 특정 대상(행)**만을 정확히 추출하여 반영해야 합니다. `.loc[]`와 다중 컬럼 선택의 조합은 이러한 정밀한 데이터 추출을 가능하게 합니다.
    * **의미**: 예를 들어, `df_financials.loc['2024Q1', ['Revenue', 'Net_Income']]`와 같이 특정 분기의 매출액과 순이익만 선택하여 분석하는 식입니다. 이는 특정 기간의 재무 성과를 요약하거나, 비교 분석하는 데 매우 효과적입니다.

결론적으로, 다중 컬럼 선택과 라벨 기반 행 선택은 CPA가 **정확하고 효율적인 데이터 접근을 통해 재무 데이터를 심층적으로 분석하고, 감사 증거를 확보하며, 특정 목적에 맞는 보고서를 작성하는 데 필수적인 역량**을 제공합니다.
"""

# ==============================================================================
# [추가 학습] NameError 이해 및 해결
# ==============================================================================

# 1. NameError 란?
"""
`NameError`는 Python에서 **정의되지 않은 변수나 함수를 호출하려 할 때** 발생하는 오류입니다.
'Name'은 변수, 함수, 클래스 등 코딩에 사용되는 '이름'을 의미하며,
'Error'는 그런 이름이 현재 스코프(코드 실행 범위) 내에서 찾아질 수 없다는 뜻입니다.

간단히 말해, "너 이런 이름(변수/함수) 쓴다고 했는데, 내가 아무리 찾아봐도 그런 이름은 없어!" 라고 Python 인터프리터가 알려주는 것입니다.
"""

# 2. Pandas 학습 중 NameError가 발생하는 흔한 경우
"""
Pandas를 다룰 때 NameError는 주로 다음과 같은 상황에서 발생합니다.

(1) 변수명 오타:
    DataFrame이나 Series의 변수 이름을 잘못 입력했을 때.
    예: `df_students`를 `df_student`로 오타.

(2) 변수 정의 전 사용:
    변수를 선언(할당)하기 전에 해당 변수를 사용하려고 할 때.
    예: `new_df = df_original` 코드 이전에 `df_original`을 사용하려 할 때.

(3) 모듈/함수 임포트 누락 또는 오타:
    사용하려는 함수나 클래스가 속한 모듈을 임포트하지 않았거나, 임포트할 때 오타가 났을 때.
    예: `pd.read_csv`를 사용해야 하는데 `import pandas`를 하지 않았거나 `pd`가 아닌 다른 이름으로 임포트했을 때.

(4) 스코프 문제:
    변수가 정의된 스코프(범위) 밖에서 해당 변수를 사용하려 할 때.
    (예: 함수 내에서 정의된 지역 변수를 함수 밖에서 호출)
"""

# 3. NameError 발생 예시 및 해결 방법

# 예시 1: 변수명 오타 (문제 4.3에서 경험할 수 있었던 경우)
"""
# 발생 상황:
# df_students = pd.read_csv(StringIO(students_data)).set_index("StudentID")
# print(df_student.loc["S002"]) # 'df_student'는 정의되지 않은 변수이므로 NameError 발생

# 해결 방법:
# 올바른 변수명인 `df_students`를 사용해야 합니다.
# print(df_students.loc["S002"])
"""
# 예시 코드 (실행 시 NameError 발생 가능):
# import pandas as pd
# from io import StringIO
# students_data_example = "StudentID,Name,Math,English,Grade\nS001,Alice,90,85,A"
# df_students_example = pd.read_csv(StringIO(students_data_example)).set_index("StudentID")
# # 아래 줄의 주석을 풀면 'df_student_example'가 정의되지 않았으므로 NameError 발생
# # print(df_student_example.loc["S002"])

# 예시 2: 모듈 임포트 누락
"""
# 발생 상황:
# read_csv("data.csv") # 'read_csv'는 정의되지 않은 함수

# 해결 방법:
# `import pandas as pd`를 통해 pandas 모듈을 임포트하고, `pd.read_csv`와 같이 사용해야 합니다.
# import pandas as pd
# pd.read_csv("data.csv")
"""

# 예시 3: 변수 정의 전 사용
"""
# 발생 상황:
# print(my_variable) # 'my_variable'은 아직 정의되지 않음
# my_variable = 10

# 해결 방법:
# 변수를 사용하기 전에 먼저 정의(할당)해야 합니다.
# my_variable = 10
# print(my_variable)
"""

# 4. NameError 발생 시 대처법
"""
1.  **에러 메시지 읽기**: `NameError: name 'xxx' is not defined` 메시지에서 'xxx'가 어떤 이름인지 확인합니다.
2.  **변수명 확인**: 해당 이름의 변수가 코드 내에서 정확하게 철자 오류 없이 정의되었는지 확인합니다.
3.  **임포트 확인**: 사용하려는 함수나 객체가 특정 라이브러리에 속한다면, 해당 라이브러리를 올바르게 임포트했는지 확인합니다. (예: `import pandas as pd`)
4.  **실행 흐름 확인**: 변수가 사용되는 시점 이전에 해당 변수가 할당되었는지, 또는 함수가 정의되었는지 코드의 실행 순서를 따라가며 확인합니다.
5.  **스코프 확인**: 특히 함수나 클래스 내부/외부에서 변수를 사용할 때 스코프 규칙을 고려합니다.
"""

# --- [정리] ---
"""
`NameError`는 코드의 가장 기본적인 오류 중 하나이지만, 초보자가 자주 마주치며 디버깅 능력을 향상시키는 데 중요한 경험을 제공합니다.
에러 메시지를 침착하게 읽고, 위에 제시된 대처법들을 적용하여 문제를 해결하는 습관을 들이세요.
"""
