# ==============================================================================
# [문제 2-1] 분기별 판매 데이터 수직 결합 및 인덱스 초기화 (Day 7 학습 내용)
# ==============================================================================

# --- [최초 나의 코딩] ---
import pandas as pd

data_q1 = {'Product': ['A', 'B', 'C'],
           'Sales': [100, 150, 200],
           'Quarter': ['Q1', 'Q1', 'Q1']}
q1_sales_df = pd.DataFrame(data_q1)

data_q2 = {'Product': ['A', 'B', 'D'],
           'Sales': [120, 180, 90],
           'Quarter': ['Q2', 'Q2', 'Q2']}
q2_sales_df = pd.DataFrame(data_q2)

data_q3 = {'Product': ['B', 'C', 'E'],
           'Sales': [250, 130, 70],
           'Quarter': ['Q3', 'Q3', 'Q3']}
q3_sales_df = pd.DataFrame(data_q3)

joined_sales_df = pd.concat([q1_sales_df, q2_sales_df, q3_sales_df], axis=0, ignore_index=True)
#ignore을 ignored로 오타해서 Error 발생
#처음에는 axis=0 이 행 기준이라, 얘가 수평 결합이라고 단순하게 생각했는데, 행 기준이라 밑으로 줄줄이 붙어서 '수직'의 의미였음

print("\n --- Joined Sales Dataframe --- \n")
print(joined_sales_df)

# --- [코드 실행 결과] ---
"""
 --- Joined Sales Dataframe ---
  Product  Sales Quarter
0       A    100      Q1
1       B    150      Q1
2       C    200      Q1
3       A    120      Q2
4       B    180      Q2
5       D     90      Q2
6       B    250      Q3
7       C    130      Q3
8       E     70      Q3
"""

# --- [피드백] ---
"""
문제 2-1을 **완벽하게 해결**하셨습니다! `pd.concat()` 함수를 사용하여 여러 DataFrame을 성공적으로 수직 결합하고, `ignore_index=True`를 통해 깔끔하게 인덱스를 초기화했습니다. 이는 데이터 통합의 핵심적인 기법을 정확히 이해하고 있음을 보여줍니다.

1.  **정확한 수직 결합**: `pd.concat([df1, df2, df3], axis=0)`를 사용하여 여러 DataFrame을 행 방향으로 올바르게 연결했습니다. `axis=0`은 행을 기준으로 결합한다는 의미로, 데이터가 아래로 쌓이는 '수직' 결합에 해당합니다. 이에 대한 스스로의 고민과 이해(처음에는 수평으로 오해했으나 '밑으로 줄줄이 붙어서 수직'이라는 깨달음)는 개념을 더욱 깊이 있게 파악하는 데 도움이 되었을 것입니다.
2.  **`ignore_index=True`의 적절한 활용**: 연결 전 각 DataFrame이 독립적인 인덱스를 가지고 있었지만, `ignore_index=True`를 사용하여 통합된 DataFrame에 0부터 시작하는 새로운 연속적인 인덱스를 부여했습니다. 이는 데이터 통합 후 분석의 용이성과 안정성을 높이는 매우 좋은 습관입니다.
3.  **오타를 통한 학습**: `ignore_index`를 `ignored_index`로 오타하여 에러를 겪고 해결하신 경험은 실제 코딩 학습 과정에서 매우 중요합니다. 에러 메시지를 통해 올바른 매개변수 이름을 찾아내고 문제를 해결하는 과정 자체가 학습의 깊이를 더하는 효과적인 방법입니다.

이 풀이는 시계열 데이터나 분산된 기록을 통합하여 전체적인 분석을 수행해야 할 때 사용하는 Pandas의 필수적인 기능에 대한 모범적인 예시입니다.
"""

# --- [모범 답안] ---
# 이미 '최초 나의 코딩'에서 모범적으로 해결되었으므로, 추가적인 모범 답안은 생략합니다.
# 다만, 결과를 변수에 할당하고 출력 메시지를 명확히 하는 것은 좋은 습관입니다.

# total_sales_df = pd.concat([q1_sales_df, q2_sales_df, q3_sales_df], axis=0, ignore_index=True)
# print("\n--- 전체 판매 데이터 통합 결과 ---")
# print(total_sales_df)


# --- [학습 기록] ---
"""
**학습 질문**: 여러 분기 또는 기간별로 분리된 판매 데이터를 하나의 데이터프레임으로 합치고 싶을 때 어떻게 해야 할까? 이때 기존 인덱스가 중복되지 않도록 새롭게 부여하는 방법은?

**문제 해결**:
1.  **데이터프레임 준비**: 2024년 1분기, 2분기, 3분기의 판매 데이터를 각각 `q1_sales_df`, `q2_sales_df`, `q3_sales_df`로 생성했습니다. 각 데이터프레임은 동일한 컬럼 구조를 가집니다.
2.  **`pd.concat()` 함수 사용**:
    * `pd.concat([q1_sales_df, q2_sales_df, q3_sales_df], ...)`: 리스트 형태로 합치고자 하는 DataFrame들을 `pd.concat()` 함수의 첫 번째 인자로 전달했습니다.
    * `axis=0`: DataFrame을 행(row)을 기준으로 연결하도록 지정했습니다. 이는 새로운 행을 추가하여 데이터를 아래로 쌓는 '수직' 결합을 의미합니다. 만약 `axis=1`로 설정했다면 열(column)을 기준으로 옆으로 붙이는 '수평' 결합이 됩니다.
    * `ignore_index=True`: 각 원본 DataFrame의 기존 인덱스를 무시하고, 최종 연결된 DataFrame에 0부터 시작하는 새로운 연속적인 인덱스를 부여하도록 지정했습니다. 이 옵션이 없다면 원본 DataFrame들의 인덱스가 그대로 유지되어 중복될 수 있습니다.
3.  **결과 확인**: 출력된 `joined_sales_df`를 통해 세 분기의 판매 데이터가 하나의 DataFrame으로 통합되었고, 인덱스가 0부터 8까지의 연속적인 숫자로 새롭게 할당된 것을 확인했습니다.

**추가 학습 (공인회계사 업무와의 관련성 및 `pd.concat()`의 활용)**:

`pd.concat()`를 활용한 **수직 결합(`axis=0`)**은 공인회계사(CPA)가 **분산된 재무 및 운영 데이터를 통합하여 전체적인 그림을 파악하고, 포괄적인 분석을 수행하는 데 필수적인 기능**입니다. 이는 특히 시계열 데이터 통합, 대량 데이터 처리, 그리고 완전성 검증 시 매우 중요합니다.

* **기간별 재무 보고서 통합**:
    * **예시**: 월별 또는 분기별로 추출된 **총계정원장(GL) 데이터, 판매 명세서, 구매 명세서** 등 동일한 형식의 재무 데이터를 하나의 통합된 데이터셋으로 합칩니다.
        * CPA는 이를 통해 특정 회계연도 전체의 총 매출, 총 비용, 특정 계정의 연간 거래 내역 등을 손쉽게 집계하고, 재무제표 작성의 기반 데이터를 마련할 수 있습니다.
        * 월별, 분기별 실적 추이 분석이나 연간 예산 대비 실적 분석 시 유용합니다.

* **여러 사업장/지점 데이터 통합 및 비교**:
    * **예시**: 국내외 **여러 사업장이나 지점으로부터 수집된 동일 형식의 판매, 비용, 재고 데이터**를 한데 모읍니다.
        * 이를 통해 CPA는 전사적인 관점에서 재무 성과를 비교하고, 특정 지점의 이상치 또는 효율성 문제를 식별할 수 있습니다. 예를 들어, 모든 지점의 판매 데이터를 통합하여 가장 높은/낮은 판매량을 기록한 지점을 파악하는 등의 분석이 가능합니다.

* **데이터 완전성 검증 및 누락 확인**:
    * **예시**: 회계 시스템에서 추출한 **연속적인 전표 번호 데이터**와 실제로 시스템에 입력된 **전표 기록 데이터**를 병합하여, 누락된 전표 번호가 있는지 확인합니다.
        * 서로 다른 기간 또는 다른 모듈에서 생성된 전표들을 `concat`으로 합친 후, 전표 번호를 기준으로 정렬하고 연속성 검사를 수행하여 빠진 전표가 없는지 검증할 수 있습니다.
    * **활용**: 특정 고객 또는 공급업체와의 모든 거래 내역을 통합하여, 총 거래량이나 미결제 잔액을 계산하고, 의심스러운 거래 패턴을 탐지합니다.

* **`ignore_index=True`의 실용적 중요성**:
    * 데이터를 통합할 때 각 원본 DataFrame의 인덱스가 유지되면, 필터링이나 추가적인 분석 시 **인덱스 중복으로 인한 오류**가 발생할 수 있습니다. 특히 Pandas의 인덱스 기반 선택(loc, iloc)을 사용할 때 문제가 될 수 있습니다.
    * `ignore_index=True`는 이러한 문제를 방지하고, 통합된 데이터셋에 깨끗하고 새로운 인덱스를 부여하여 **후속 데이터 처리 및 분석의 안정성과 효율성**을 크게 높여줍니다. CPA는 이 옵션을 통해 통합된 데이터셋의 무결성을 유지할 수 있습니다.

결론적으로, `pd.concat()`의 수직 결합은 CPA가 **분산된 대규모 데이터를 효과적으로 집계하고, 전체적인 관점에서 재무 및 운영 흐름을 분석하며, 데이터의 완전성과 일관성을 검증하는 데 필수적인 첫 단계**라고 할 수 있습니다.
"""
