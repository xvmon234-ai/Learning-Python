# ==============================================================================
# [문제 1-3] 다중 키 및 상이한 키 이름 병합 (Day 7 학습 내용)
# ==============================================================================

# --- [최초 나의 코딩] ---
import pandas as pd

data_sales_records = {'RecordID': [1, 2, 3, 4],
                      'ItemCode': ['A101', 'B202', 'A101', 'C303'],
                      'SaleDate': ['2023-01-10', '2023-01-12', '2023-01-10', '2023-01-15'],
                      'Quantity': [5, 2, 8, 3]}
sales_records_df = pd.DataFrame(data_sales_records)

data_product_details = {'ProductCode': ['A101', 'B202', 'D404'],
                        'ManufacturingDate': ['2023-01-10', '2023-01-12', '2023-01-15'],
                        'Description': ['Laptop', 'Mouse', 'Monitor'],
                        'UnitCost': [800, 20, 250]}
product_details_df = pd.DataFrame(data_product_details)

df_joined = pd.merge(sales_records_df, product_details_df, left_on=["ItemCode", "SaleDate"], right_on=["ProductCode", "ManufacturingDate"], how="inner")
#AI에게 추가적인 질문 없이 해결함, 리스트랑 딕셔너리 등 풀었던 기억으로

print("\n --- Inner Joined Dataframe --- \n")
print(df_joined)

# --- [코드 실행 결과] ---
"""
 --- Inner Joined Dataframe ---
   RecordID ItemCode    SaleDate  Quantity ProductCode ManufacturingDate Description  UnitCost
0         1     A101  2023-01-10         5        A101        2023-01-10    Laptop       800
1         3     A101  2023-01-10         8        A101        2023-01-10    Laptop       800
2         2     B202  2023-01-12         2        B202        2023-01-12     Mouse        20
"""

# --- [피드백] ---
"""
문제 1-3을 **완벽하게 해결**하셨습니다! 여러 개의 컬럼을 조인 키로 사용하고, 각 DataFrame에서 조인할 컬럼의 이름이 다를 때 `left_on`과 `right_on` 매개변수에 리스트를 사용하여 정확하게 병합했습니다. 이는 `pd.merge()`의 고급 기능을 능숙하게 다룬다는 것을 보여주는 훌륭한 예시입니다.

1.  **다중 키 조인**: `left_on=["ItemCode", "SaleDate"]`와 `right_on=["ProductCode", "ManufacturingDate"]`를 통해 **두 개의 컬럼 쌍을 기준으로 데이터를 매칭**한 것은 매우 인상적입니다. 단일 키로는 불가능한 정교한 매칭을 구현했습니다.
2.  **상이한 키 이름 처리**: 각 데이터프레임의 조인 키 컬럼 이름이 다름에도 불구하고, `left_on`과 `right_on`을 명확히 지정하여 혼란 없이 정확하게 매핑했습니다. 이는 실제 데이터 분석 시 흔히 마주치는 상황에 대한 뛰어난 대처 능력입니다.
3.  **정확한 `inner` 조인 활용**: `how="inner"`를 사용하여 두 조건(제품 코드와 날짜)이 모두 일치하는 레코드만을 추출함으로써, 판매 기록과 제품 상세 정보가 완벽히 매칭되는 유효한 데이터를 얻었습니다. 예를 들어, `sales_records_df`의 'C303' (2023-01-15)이나 `product_details_df`의 'D404' (2023-01-15)와 같이 한쪽에만 존재하는 레코드는 최종 결과에서 제외된 것을 통해 `inner` 조인의 작동 원리를 정확히 이해하고 있음을 알 수 있습니다.

**스스로 해결해내신 점이 특히 훌륭합니다.** 리스트와 딕셔너리에 대한 기존 학습 경험을 바탕으로 복합적인 문제에 대한 해결책을 찾아낸 것은 Pandas에 대한 깊은 이해와 문제 해결 능력을 동시에 보여줍니다.

이 풀이는 복잡한 비즈니스 규칙에 따라 데이터를 통합하고, 여러 요소를 동시에 고려하여 데이터의 정확성을 검증하는 데 필수적인 역량을 입증합니다.
"""

# --- [모범 답안] ---
# '최초 나의 코딩'에서 이미 모범적으로 해결되었으므로, 추가적인 모범 답안은 생략합니다.
# 다만, 결과를 변수에 할당하고 출력 메시지를 명확히 하는 것이 좋은 습관입니다.

# merged_sales_details_df = pd.merge(sales_records_df, product_details_df,
#                                    left_on=["ItemCode", "SaleDate"],
#                                    right_on=["ProductCode", "ManufacturingDate"],
#                                    how="inner")
# print("\n--- 판매 기록 및 제품 상세 정보 통합 (다중 키 Inner Join) 결과 ---")
# print(merged_sales_details_df)


# --- [학습 기록] ---
"""
**학습 질문**: 물품 판매 기록과 제품 상세 정보를 품목 코드와 판매/제조 일자를 모두 기준으로 통합하려면 어떻게 해야 할까? 서로 다른 이름의 여러 키를 동시에 사용하는 조인 방식은 무엇일까?

**문제 해결**:
1.  **데이터프레임 준비**: 물품 판매 기록을 담은 `sales_records_df`와 제품 상세 정보를 담은 `product_details_df`를 생성했습니다. 두 데이터프레임은 품목 코드와 날짜 정보를 각각 다른 컬럼 이름으로 가지고 있습니다 (`ItemCode` vs `ProductCode`, `SaleDate` vs `ManufacturingDate`).
2.  **`pd.merge()` 함수와 다중 키 조인 사용**:
    * `pd.merge(sales_records_df, product_details_df, ...)`: `sales_records_df`를 '왼쪽', `product_details_df`를 '오른쪽'으로 지정했습니다.
    * `left_on=["ItemCode", "SaleDate"]`: 왼쪽 DataFrame에서 조인 기준으로 사용할 컬럼들을 리스트로 묶어 지정했습니다.
    * `right_on=["ProductCode", "ManufacturingDate"]`: 오른쪽 DataFrame에서 조인 기준으로 사용할 컬럼들을 리스트로 묶어 지정했습니다. 이 두 리스트는 요소의 순서가 중요합니다. `left_on`의 첫 번째 요소는 `right_on`의 첫 번째 요소와, 두 번째 요소는 두 번째 요소와 매칭됩니다.
    * `how="inner"`: 양쪽 데이터프레임에서 두 개의 조인 키(컬럼 쌍)가 모두 일치하는 레코드만 결과에 포함되도록 `inner` 조인 방식을 선택했습니다.
3.  **결과 확인**: 병합된 `df_joined` DataFrame을 출력한 결과, `ItemCode`와 `SaleDate`가 `ProductCode`와 `ManufacturingDate`에 동시에 일치하는 레코드들만 정확하게 통합되어 있음을 확인했습니다. 'C303'과 'D404' 관련 레코드는 어느 한쪽에서만 존재하므로 결과에서 제외되었습니다.

**추가 학습 (공인회계사 업무와의 관련성 및 다중 키 조인의 활용)**:

공인회계사가 데이터를 분석하는 업무에서 **다중 키(Multiple Keys)를 활용한 병합**은 단순한 ID 매칭을 넘어서는 **정교하고 복합적인 데이터 검증 및 분석**에 필수적인 기술입니다. 이는 특히 **복잡한 비즈니스 규칙이 적용되는 거래나, 여러 속성을 동시에 고려해야 하는 감사 시나리오**에서 그 중요성이 더욱 부각됩니다.

* **정확한 거래 검증 및 일치 확인**:
    * **예시**: **판매 기록**과 **수금 기록**을 대사할 때, 단순히 '고객 ID'만으로 매칭하는 것이 아니라, '고객 ID'와 '거래 발생 일자' 그리고 '거래 금액'을 **복합적인 키로 사용하여 정확히 일치하는 수금 내역**을 찾아냅니다. 이는 동일 고객의 다른 날짜 또는 다른 금액의 거래가 잘못 매칭되는 오류를 방지하고, 특정 채권의 회수 여부를 명확히 파악하는 데 필수적입니다.
    * **활용**: **매출 누락 또는 이중 기록**을 탐지하기 위해 '고객 ID', '제품 코드', '판매 일자', '판매 금액'을 모두 키로 사용하여 매출 시스템의 기록과 재무회계 시스템의 기록을 비교합니다.

* **재고 및 자산 관리의 정합성 확인**:
    * **예시**: **재고 입출고 기록**을 검증할 때, '품목 코드'와 '창고 위치' 그리고 '입출고 일자'를 키로 사용하여 **물리적 재고 이동과 장부상 기록의 일치 여부**를 확인합니다. 이는 재고의 물리적 존재와 장부상 잔액 간의 불일치 원인(예: 잘못된 창고 이동 기록, 미반영 재고 이동)을 파적하는 데 매우 효과적입니다.
    * **활용**: **고정자산 관리**에서 '자산 ID'와 '취득 일자', '취득 금액'을 키로 사용하여 자산 대장과 회계 장부 간의 일치 여부를 검증하고, 미등록 자산이나 허위 자산을 식별합니다.

* **비용 분석 및 내부 통제 감사**:
    * **예시**: 특정 프로젝트의 **비용 지출 내역**을 감사할 때, '프로젝트 ID', '비용 계정 코드', '지출 일자'를 키로 사용하여 **승인된 예산 항목과 실제 지출 간의 일치 여부**를 정밀하게 검토합니다.
    * **활용**: 직원 경비 정산의 적정성을 검토할 때, '직원 ID', '경비 유형', '지출 일자', '지출 금액' 등을 다중 키로 사용하여 **중복 청구나 부적절한 경비 집행**을 탐지합니다.

다중 키를 활용한 조인은 CPA가 **데이터의 깊이 있는 연결성을 이해하고, 복잡한 비즈니스 규칙과 연계된 감사 포인트를 발굴하며, 재무 데이터의 완전성과 정확성을 다차원적으로 검증**하는 데 필수적인 고급 분석 기법입니다. 이는 단순한 이상 감지를 넘어, 실제 비즈니스 프로세스상의 오류나 통제 미흡을 식별하는 데 결정적인 통찰력을 제공합니다.
"""
