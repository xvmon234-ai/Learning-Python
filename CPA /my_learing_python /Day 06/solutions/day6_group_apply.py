# ==============================================================================
# [문제 6.3.3] Pandas 그룹 기반 사용자 정의 연산 (Day 6 학습 내용)
# ==============================================================================

# --- [최초 나의 코딩] ---
import pandas as pd
data = {'Category': ['Electronics', 'Clothes', 'Electronics', 'Books', 'Clothes'],
        'Product': ['TV', 'Shirt', 'Laptop', 'Novel', 'Pants'],
        'Quantity': [10, 25, 5, 15, 30],
        'Price': [500, 30, 1200, 20, 40]}
sales_df = pd.DataFrame(data)

high_price = sales_df.groupby("Category").apply(lambda x : x["Price"].nlargest(2))

print("\n--- Highest 2 Prices per Category ---")
print(high_price)

# --- [코드 실행 결과] ---
"""
--- Highest 2 Prices per Category ---
Category
Books        3    20
Clothes      4    40
             1    30
Electronics  2  1200
             0   500
Name: Price, dtype: int64
"""

# --- [피드백] ---
"""
문제 6.3.3을 **매우 훌륭하게 해결**하셨습니다! `groupby()`와 `apply()` 메서드를 조합하여 각 카테고리별로 가격이 가장 높은 상위 2개의 제품을 정확하게 추출했습니다. 이는 Pandas의 고급 그룹 연산 기능을 잘 이해하고 있음을 보여줍니다.

1.  **정확한 그룹화**: `sales_df.groupby("Category")`를 통해 제품 카테고리별로 데이터를 올바르게 그룹화했습니다.
2.  **`apply()`를 사용한 사용자 정의 연산**: `apply(lambda x : x["Price"].nlargest(2))` 구문은 `apply()` 메서드의 강력함이 잘 드러나는 부분입니다.
    * `apply()`는 각 그룹(`x`로 표현)에 대해 복잡하거나 미리 정의되지 않은 연산을 수행할 때 사용됩니다. `filter()`나 `transform()`이 특정 반환 규칙을 강제하는 반면, `apply()`는 훨씬 유연하며 어떤 형태의 Series나 DataFrame이라도 반환할 수 있습니다.
    * `lambda x : x["Price"].nlargest(2)`는 각 카테고리 그룹(`x`) 내에서 'Price' 컬럼의 값 중 가장 큰 2개를 선택하는 연산입니다. `nlargest()`는 Series 메서드로, 상위 n개의 값을 효율적으로 찾아줍니다.
    * 반환된 결과는 MultiIndex Series로, 각 카테고리 아래에 해당 카테고리 내에서 상위 2개 가격의 원본 인덱스와 값이 포함되어 있습니다. 이는 정보 파악에 매우 용용합니다.

이 풀이는 Pandas `groupby()`와 `apply()`를 이용한 복잡한 그룹별 연산의 모범적인 예시이며, 데이터 분석에서 그룹별로 맞춤형 로직을 적용할 때 매우 유용합니다.
"""

# --- [모범 답안] ---
# 이미 '최초 나의 코딩'에서 모범적으로 해결되었으므로, 추가적인 모범 답안은 생략합니다.
# 다만, 결과를 변수에 할당하는 것은 좋은 습관입니다.
# top_2_prices_per_category = sales_df.groupby("Category").apply(lambda x: x["Price"].nlargest(2))
# print("\n--- Highest 2 Prices per Category (모범 답안 예시) ---")
# print(top_2_prices_per_category)


# --- [학습 기록] ---
"""
**학습 질문**: 각 제품 카테고리별로 가격이 가장 높은 상위 2개의 제품 가격을 추출하려면 어떻게 해야 할까? `groupby()`와 `apply()`는 언제 사용하며, 다른 그룹 메서드와 어떤 차이가 있을까?

**문제 해결**:
1.  **데이터프레임 준비**: 문제에서 주어진 판매 데이터를 포함하는 `sales_df`를 생성했습니다.
2.  **`groupby()`로 그룹화**: `sales_df.groupby("Category")`를 사용하여 데이터를 `'Category'` 컬럼을 기준으로 그룹화했습니다.
3.  **`apply()`를 이용한 사용자 정의 연산**: 그룹화된 객체에 `.apply()` 메서드를 적용하여 각 그룹에 대한 맞춤형 연산을 수행했습니다.
    * `apply()`는 그룹 객체에 Series 또는 DataFrame을 반환하는 함수를 적용할 때 주로 사용됩니다. 이 함수의 인자 `x`는 각 그룹에 해당하는 DataFrame(또는 Series)이 됩니다.
    * `lambda x : x["Price"].nlargest(2)`: 각 카테고리 그룹 `x` 내에서 'Price' 컬럼만 선택한 후, `.nlargest(2)` 메서드를 사용하여 해당 그룹의 가격 중 가장 큰 2개의 값을 Series 형태로 반환하도록 했습니다. `nlargest()`는 `sort_values(ascending=False).head(n)`과 유사하지만, 더 효율적입니다.
4.  **결과 확인**: 출력된 결과는 `Category`와 원본 인덱스가 MultiIndex로 구성된 Series 형태로, 각 카테고리별 상위 2개 가격이 정확하게 표시되었음을 확인했습니다.

**추가 학습 (공인회계사 업무와의 관련성 및 `apply()`의 활용)**:

`groupby().apply()`는 `filter()`나 `transform()`으로는 해결하기 어려운 **복잡하고 유연한 그룹별 맞춤형 연산**을 수행할 때 매우 강력합니다. 특히, 공인회계사 업무에서 다음과 같은 시나리오에서 유용하게 사용될 수 있습니다:

* **중요성 평가 및 표본 추출**:
    * **예시**: 각 계정(예: 매출채권, 재고자산)별로 **가장 큰 금액의 거래 또는 이상치가 의심되는 상위 N개 거래**를 추출하여 감사 표본으로 선정할 때 활용할 수 있습니다.
        `df.groupby('계정과목')['금액'].apply(lambda x: x.nlargest(5))` -> 각 계정과목에서 금액이 가장 큰 상위 5개 거래 추출
    * **예시**: 특정 비용 계정 내에서 **가장 큰 지출 항목들을 식별**하여 해당 지출의 적정성 및 증빙 유무를 집중적으로 검토합니다.
        `df.groupby('비용항목')['지출액'].apply(lambda x: x[x > x.mean() + 3*x.std()])` -> 평균에서 3표준편차 이상 벗어나는 이상 지출 항목 탐지
* **복잡한 재무 지표 계산**:
    * **예시**: 각 사업부별로 **특정 시점까지의 누적 손익**을 계산하거나, 특정 비율(예: 부채비율)이 기준치를 넘는 기간을 식별하는 등, 단순 집계를 넘어선 복합적인 재무 지표를 그룹별로 산출할 때 유용합니다.
        `df.groupby('사업부').apply(lambda x: x['매출액'].sum() - x['비용'].sum())` -> 각 사업부별 총 이익 계산
* **비정형 데이터 분석**: 텍스트 데이터와 같은 비정형 데이터를 그룹별로 처리해야 할 때, 예를 들어 각 고객 그룹별로 가장 자주 사용된 키워드를 추출하는 등의 작업에 `apply()`를 사용할 수 있습니다.

**`apply()` vs `agg()`, `filter()`, `transform()`**:
* **`agg()`**: 그룹별로 **하나의 스칼라 값(집계 결과)**을 반환할 때 주로 사용됩니다 (예: 합계, 평균, 개수). 결과의 형태가 예측 가능합니다.
* **`filter()`**: 그룹 **전체**를 필터링하여 조건에 맞는 그룹의 모든 원본 행을 반환합니다. 결과의 행 수가 원본과 같거나 적습니다.
* **`transform()`**: 그룹별 연산을 수행하지만, 결과의 길이가 **원본 DataFrame의 길이와 동일**하게 매핑되어 개별 행에 값을 추가하거나 변환할 때 사용됩니다.
* **`apply()`**: 가장 유연하며, 위 세 가지 메서드로 해결하기 어려운 **어떤 종류의 Series 또는 DataFrame이라도 반환**할 수 있습니다. 그룹 내에서 복잡한 로직을 수행하고 싶을 때 선택하는 '만능 도구'에 가깝습니다. 하지만 유연성만큼 성능 측면에서는 다른 특정 목적 메서드보다 느릴 수 있으므로, 가능하다면 `agg()`, `filter()`, `transform()`을 우선 고려하는 것이 좋습니다.

결론적으로, `apply()`는 공인회계사가 **정형화되지 않은 복잡한 그룹별 분석이나 특정 조건에 따른 심층적인 데이터 발췌**를 수행해야 할 때 매우 유용한 도구입니다.
"""
