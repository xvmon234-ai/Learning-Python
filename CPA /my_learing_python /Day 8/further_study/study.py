Day 8 - 실전 모의고사 1회: 추가 학습 내용 (이론편)

# ==============================================================================
# 1. Pandas DataFrame과 Series의 구조와 차이점
# ==============================================================================
# - DataFrame:
#   - 2차원 테이블 형태의 데이터 구조로, 여러 개의 Series가 합쳐진 형태입니다.
#   - 행(index)과 열(column)을 가지고 있으며, 각 열은 Series로 구성됩니다.
#   - SQL의 테이블, 엑셀 스프레드시트와 유사한 구조입니다.
#   - 예: df = pd.read_csv(...)
#
# - Series:
#   - 1차원 배열과 유사한 데이터 구조로, 하나의 컬럼에 해당합니다.
#   - 인덱스와 값(value)을 가집니다.
#   - 예: df['컬럼명']
#
# - 학습 교훈:
#   - `df = df['컬럼명'].fillna(...)`와 같이 Series에 대한 연산 결과를 다시 df 변수에 할당하면,
#     df가 전체 DataFrame이 아닌 1차원 Series로 바뀌어 버립니다.
#   - 따라서, `df['컬럼명'] = df['컬럼명'].fillna(...)`와 같이 특정 컬럼에 결과를 재할당해야
#     DataFrame의 구조를 온전히 유지할 수 있습니다.

# ==============================================================================
# 2. 벡터화 연산 (Vectorization)
# ==============================================================================
# - 개념:
#   - 데이터 배열에 대한 연산을 단일 명령으로 처리하는 방식입니다.
#   - Python의 for 반복문을 사용하는 대신, Pandas나 NumPy와 같은 라이브러리가 제공하는
#     최적화된 C 언어 기반의 함수들을 활용하여 데이터를 한 번에 처리합니다.
#
# - 장점:
#   - 압도적으로 빠른 연산 속도: for 루프는 한 번에 하나의 요소씩 처리하지만, 벡터화 연산은
#     여러 요소를 동시에 처리(병렬 처리)하여 효율성이 극대화됩니다.
#   - 코드 간결성: 반복문을 작성할 필요 없이 한 줄로 표현할 수 있어 코드가 간결하고 가독성이 높아집니다.
#
# - 학습 교훈:
#   - `if-else` 문을 통해 각 행을 순회하며 조건을 판단하는 대신, `np.where()`와 같은
#     벡터화된 함수를 사용하여 성능 저하를 방지해야 합니다.

# ==============================================================================
# 3. np.where() 함수 심층 이해
# ==============================================================================
# - 구조: `np.where(condition, value_if_true, value_if_false)`
#   - condition: True 또는 False 값을 담고 있는 Boolean Series 또는 배열입니다.
#     (예: `df['Useful_Life_Years'] > 0`)
#   - value_if_true: condition이 True인 경우 할당할 값입니다.
#   - value_if_false: condition이 False인 경우 할당할 값입니다.
#
# - 작동 원리:
#   - `np.where()`는 condition 배열을 따라가며 True/False 여부에 따라
#     value_if_true 또는 value_if_false 값을 선택하여 새로운 배열을 만듭니다.
#   - 이 과정은 C 레벨에서 빠르게 처리되므로, 파이썬의 `for` 반복문보다 훨씬 효율적입니다.

# ==============================================================================
# 4. 다중 조건 필터링의 논리 연산자
# ==============================================================================
# - `&` (and):
#   - 두 조건이 모두 True일 때만 True를 반환합니다.
#   - 예: `(df['Status'] == 'Active') & (df['Book_Value'] > 100000000)`
#
# - `|` (or):
#   - 두 조건 중 하나라도 True이면 True를 반환합니다.
#   - 예: `(df['Department'] == 'Sales') | (df['Department'] == 'Marketing')`
#
# - 주의사항:
#   - `and`나 `or` 키워드는 Pandas에서는 사용할 수 없습니다.
#   - 각 조건은 반드시 괄호 `()`로 감싸야 연산자 우선순위로 인한 오류를 방지할 수 있습니다.

# ==============================================================================
# 5. groupby()의 동작 방식 및 reset_index()
# ==============================================================================
# - `groupby()`의 기본 동작:
#   - 지정된 컬럼을 기준으로 데이터를 그룹화합니다.
#   - 그룹화된 결과는 인덱스가 그룹화 기준 컬럼으로 설정된 상태가 됩니다.
#   - 예: `df.groupby('Department')['Book_Value'].sum()`을 실행하면,
#     `Department`가 새로운 인덱스가 되고, `Book_Value`의 합이 값으로 들어간 Series가 반환됩니다.
#
# - `reset_index()`의 역할:
#   - `groupby()`로 인해 인덱스로 설정된 컬럼을 다시 일반 컬럼으로 되돌립니다.
#   - 새로운 인덱스는 0부터 시작하는 숫자로 자동 생성됩니다.
#   - `df_summary = df_grouped.reset_index()`를 통해 깔끔한 DataFrame 형태로 만들 수 있어
#     이후 CSV 저장이나 데이터프레임 병합 작업에 유용합니다.
