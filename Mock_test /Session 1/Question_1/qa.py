# samil_accounting_firm_interview_feedback_1_1.py

# ==============================================================================
# 삼일회계법인 신입공인회계사 디지털 전형 과제 면접 - 1일차 1회차 (자동화 스크립트 작성) 질의응답 피드백
# ==============================================================================

# 이 파일은 1일차 1회차 과제 수행 후 진행된 질의응답 내용을 담고 있으며,
# 지원자님의 답변과 그에 대한 면접관의 피드백을 포함합니다.

# ---
# 면접관 (프로그래밍 개발자) 질의 및 답변 피드백
# ---

# Q1. pd.concat vs. pd.merge 선택 이유 및 차이점
#    두 개의 DataFrame을 병합할 때 pd.concat을 사용했습니다. pd.concat 외에 DataFrame을 병합하는 다른 방법(예: pd.merge)이 있는데, 이 과제에서는 왜 pd.concat을 선택했습니까? 그리고 pd.concat과 pd.merge의 주요 차이점은 무엇이라고 생각합니까?

# --- 지원자님 답변 ---
# 1. 먼저, 제시해준 데이터프레임들의 컬럼이 달랐기 때문에 동일한 키를 반드시 가지고 있어야 하는 merge보다는 concat이 오류의 발생 가능성이 더 낮다고 판단하였음, 또한 문제에서 제시해준 병합의 목적이 단순한 합산이었기 때문에 논리적 연결에 더욱 적합한 merge보다는 concat이 더 적합하다고 생각

# --- 피드백 ---
# 평가: 매우 명확하고 정확하게 답변해 주셨습니다.
# 'concat'이 컬럼명이 다르더라도 단순히 행을 합치는 데 유용하며, 'merge'는 공통된 키(Key)를 기준으로 데이터프레임을 결합하는 데 사용된다는 핵심적인 차이점을 잘 이해하고 계십니다. 문제의 목적(단순 합산)에 따라 'concat'을 선택한 판단 또한 적절했습니다.

# Q2. index=False 옵션의 역할 및 생략 시 문제점
#    데이터를 CSV 파일로 저장할 때 index=False 옵션을 사용했습니다. 이 옵션의 역할은 무엇이며, 이를 생략했을 때 발생할 수 있는 잠재적인 문제점은 무엇일까요?

# --- 지원자님 답변 ---
# 2. index=False는 원본 그 자체를 변경시킴, 만약 이를 수행하지 않으 시에는 rename을 했음에도 원본이 변경되지 않아 둘이 합상되지 않는 오류가 발생할 수 있기 때문에 이를 반드시 수행해야 함

# --- 피드백 ---
# 평가: 이 부분은 정확한 이해에 조금 차이가 있습니다.
# 'index=False'는 'to_csv()' 함수에서 DataFrame의 **인덱스(index)를 CSV 파일에 별도의 컬럼으로 저장하지 않도록** 하는 옵션입니다.
# 'inplace=True' (예: 'df.rename(columns=..., inplace=True)')는 DataFrame 객체 자체를 변경할 때 사용되며, 'index=False'와 직접적인 관련이 없습니다.
# 만약 'index=False'를 생략한다면, CSV 파일의 첫 번째 컬럼에 '0, 1, 2, ...'와 같은 DataFrame의 인덱스가 추가되어 저장됩니다. 이는 데이터 분석 시 불필요한 컬럼으로 인식될 수 있으며, 재분석할 때 추가적인 전처리(해당 인덱스 컬럼 제거)가 필요하게 되는 문제입니다. 파일 자체의 오류를 발생시키기보다는 **불필요한 데이터를 포함시켜 파일 형식을 완벽하게 만들지 못하는 문제**가 발생합니다.

# ---
# 면접관 (회계사) 질의 및 답변 피드백
# ---

# Q3. 데이터 형식 불일치 시 회계 실무적 문제점 및 통제 방안
#    다른 부서에서 제출된 비용 보고서의 컬럼명이 다른 경우를 처리했습니다. 실제 업무 환경에서 이처럼 데이터 형식이 통일되지 않을 때 발생할 수 있는 회계 실무적 문제점은 무엇이며, 이를 방지하기 위한 통제 방안은 무엇이 있을까요?

# --- 지원자님 답변 ---
# 3. print("df1 columns:", df1.columns), print("df2 columns:", df2.columns) 와 같이 둘을 비교 분석하기 이전에 각 칼럼명이 무엇인지 확인하는 팁을 활용하겠습니다, 이를 통해 둘의 칼럼의 차이가 발생한다는 사실을 안다면 위의 rename을 활용해 칼럼명을 통일시킬 수 있기 때문입니다

# --- 피드백 ---
# 평가: 컬럼명을 확인하고 'rename'을 통해 통일하는 방법은 **발견된 문제를 해결하는 실용적인 팁**으로서 훌륭합니다.
# 하지만 질문은 한 단계 더 나아가 **"실무적 문제점"**과 이를 **"방지하기 위한 통제 방안"**에 대한 것이었습니다.
# 실무적 문제점: 데이터 형식 불일치는 보고서 작성 지연, 데이터 오류로 인한 잘못된 의사결정, 수동 작업 증가로 인한 비효율성 및 인적 오류 발생 가능성 증대, 내부 통제의 취약성 노출 등으로 이어질 수 있습니다.
# 통제 방안:
#    - **표준화된 양식 강제**: 부서별 보고서 제출 시 사전에 정의된 표준화된 양식(템플릿)을 사용하도록 의무화합니다.
#    - **자동화된 유효성 검사**: 데이터가 시스템에 입력되거나 취합될 때, 컬럼명, 데이터 타입, 값 범위 등을 자동으로 검사하는 스크립트나 시스템을 구축합니다.
#    - **데이터 거버넌스**: 데이터를 생성하고 관리하는 전 과정에 대한 명확한 정책과 책임을 설정하여 데이터의 품질을 유지합니다.
#    - **정기적인 교육**: 데이터를 다루는 직원들에게 표준 양식 사용법과 데이터 품질의 중요성에 대해 정기적으로 교육합니다.

# Q4. 특정 부서의 'IT' 비용 추가 분석 방법
#    'IT' 및 'Travel' 카테고리의 비용을 필터링하고 집계했습니다. 만약 여러 부서의 비용 데이터가 통합된 상황에서, 특정 부서의 'IT' 비용만 추가적으로 분석해야 한다면 어떤 방식으로 데이터를 필터링하고 집계할 수 있을까요?

# --- 지원자님 답변 ---
# 4. 지금 저의 수준에서라면 df_combined를 활용해 IT의 비용만 필터링해서 df_IT_filtered와 같은 별도의 변수에 할당하도록 하겠습니다, 그렇게해서 해당 데이터만 분리해 분석을 하는데 용이하고 원본 데이터가 이로 인해 훼손되는 것을 방지하도록 하겠습니다

# --- 피드백 ---
# 평가: 'df_combined'에서 'IT' 비용을 필터링하여 별도 변수에 할당하는 것은 좋은 접근 방식이며, 원본 데이터 보존 측면에서 올바른 판단입니다.
# 다만, 질문에서는 **"특정 부서의 'IT' 비용만"** 이라고 명시했습니다. 현재 제공된 데이터셋에는 'Department' 컬럼이 없었기 때문에 특정 부서로의 추가 필터링은 불가능했습니다. (이 부분은 제가 제공한 데이터셋의 한계이므로 지원자님의 답변에 오류가 아닙니다.)
# 만약 데이터셋에 'Department' 컬럼이 있었다면, 다음과 같이 두 가지 조건을 동시에 적용하여 필터링할 수 있었을 것입니다.
# 예시: `filtered_data = df_combined[(df_combined["Category"] == "IT") & (df_combined["Department"] == "회계부")]`
# 답변 시에는 "현재 데이터셋에는 부서 정보가 없지만, 만약 'Department' 컬럼이 있었다면 논리 AND(&) 연산자를 사용하여 'Category'와 'Department' 두 조건을 동시에 필터링할 수 있었을 것"과 같이 데이터셋의 한계를 언급하며 답변하면 더욱 완벽했을 것입니다.
